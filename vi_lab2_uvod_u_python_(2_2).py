# -*- coding: utf-8 -*-
"""VI Lab2: Uvod u Python (2/2)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19f7Ek-xHFZC4GqeiynRLs93VymFw1nLg

### Učitavanje podataka iz datoteke *dataset.csv*
"""

import pandas as pd # ucitaj Pandas

data = pd.read_csv('dataset.csv') # ucitaj podatke

data # ispisi podatke

"""### Zadatak 1 - Obrada podataka kroz Pandas

####(a)  Učitati datoteku kao Pandas DataFrame, te prikazati prvih 5 i posljednjih 10 unosa u istoj;
"""

data.head()

data.tail(10)

"""####(b) Ispisati samo podatke vezane za redovne parcijalne ispite (kolone *Ispit1* i *Ispit2* );

"""

data[['Ispit1', 'Ispit2']]

"""####(c) Ispisati sve studente koji su izgubili prisustvo;

"""

data.loc[data['Prisustvo'] == 0]

"""####(d) Ispisati indeks, ukupne bodove, i ocjenu, za sve studente koji su upisali ocjenu 8 ili više;

"""

data.loc[data['Ocjena']>='8',['Indeks', 'UKUPNO','Ocjena']]

"""####(e) Sve nedostajuće vrijednosti (označene sa simbolom /) zamijeniti sa vrijednošću `np.nan`;"""

data.replace('/', np.nan, inplace=True)
data # svaka pojava / zamijenjena sa NaN

"""####(f) Iz skupa podataka odbaciti sve studente koji nemaju upisanu ocjenu;"""

data = data.loc[data['Ocjena'] >= '6' ]
data

"""####(g) Kreirati novu kolonu *Ispit1_final* u koju ćete za svakog studenta upisati onaj rezultat ispita koji je bolji (naprimjer, ako je student bolje uradio popravni ispit, onda tu pišete bodove sa popravnog, a u protivnom sa redovnog);"""

new1 = pd.read_csv('dataset.csv') 
new2 = pd.read_csv('dataset.csv') 
new1 = new1.loc[data['Ispit1'] > data['Ispit1_popravni'],['Indeks', 'Ispit1']]
new2 = new2.loc[data['Ispit1'] < data['Ispit1_popravni'],['Indeks', 'Ispit1_popravni']]


data['Ispit1_final'] = '/'


data

import numpy as np

new = pd.read_csv('dataset.csv') 
data.loc[data['UKUPNO'] > 43]

['Ispit1', 'Ispit1_popravni']

data.to_numpy()


data['Ispit1_final'] = niz_vrijednosti
data

"""### Zadatak 2 - Normalizacija podataka pomoću Sklearn

####(a)  Učitati datoteku izvjestaj.csv kao Pandas DataFrame;
"""

import pandas as pd # ucitaj Pandas

data = pd.read_csv('dataset.csv') # ucitaj podatke

data # ispisi podatke

"""####(b) Za kolone koje predstavljaju redovne ispite, izvršiti zamjenu nedostajućih vrijednosti strategijom median;"""

from sklearn.impute import SimpleImputer
data.replace('/', np.nan, inplace=True)
si = SimpleImputer(strategy='median')

print('Prije zamjene: ')
print(data.loc[:5, ['Ispit1', 'Ispit2']])

data.loc[:, 'Ispit1'] = si.fit_transform(data.loc[:, 'Ispit1'].values.reshape(-1,1))
data.loc[:, 'Ispit2'] = si.fit_transform(data.loc[:, 'Ispit2'].values.reshape(-1,1))


print('Nakon zamjene: ')
print(data.loc[:5, ['Ispit1', 'Ispit2']])

"""####(c) Za kolone koje predstavljaju popravne ispite, izvršiti zamjenu nedostajućih vrijednosti pomoću strategije mean;"""

si = SimpleImputer(strategy='mean')

print('Prije zamjene: ')
print(data.loc[:5, ['Ispit1_popravni', 'Ispit2_popravni']])

data.loc[:, 'Ispit1_popravni'] = si.fit_transform(data.loc[:, 'Ispit1_popravni'].values.reshape(-1,1))
data.loc[:, 'Ispit2_popravni'] = si.fit_transform(data.loc[:, 'Ispit2_popravni'].values.reshape(-1,1))

print('Nakon zamjene: ')
print(data.loc[:5, ['Ispit1_popravni', 'Ispit2_popravni']])

"""####(d) Izvršiti Z-score normalizaciju vrijednosti za redovne parcijalne ispite;"""

from sklearn.preprocessing import scale

data['Ispit1'] = scale(data['Ispit1']) # Z score
data['Ispit2'] = scale(data['Ispit2']) # Z score

data.loc[:5, ['Ispit1', 'Ispit2']]

"""####(e) Izvršiti MinMax normalizaciju vrijednosti za popravne parcijalne ispite;"""

from sklearn.preprocessing import MinMaxScaler

mm = MinMaxScaler()

data['Ispit1_popravni'] = mm.fit_transform(data['Ispit1_popravni'].values.reshape(-1,1))
data['Ispit2_popravni'] = mm.fit_transform(data['Ispit2_popravni'].values.reshape(-1,1))

data.loc[:5, ['Ispit1_popravni', 'Ispit2_popravni']]

"""####(f) Sve ostale nedostajuće vrijednosti u skupu podataka zamijeniti sa nulama;"""

data.replace(np.nan, 0, inplace=True)
data

"""####(g) Izdvojiti kolonu *Ocjena* u posebnu varijablu, na način da sada u originalnom skupu podataka ta kolona više ne postoji"""

new = data.loc[:,['Ocjena']]
data.drop(columns=['Ocjena'], inplace=True)
data.head()

"""####(h) Konvertovati obje varijable (originalni skup podataka bez kolone *Ocjena*, kao i posebnu kolonu *Ocjena*) u NumPy nizove;

"""

data.to_numpy()
new.to_numpy()

"""####(i) Ukoliko pretpostavimo da NumPy niz sa ocjenama predstavlja labele, a niz sa ostalim kolonama atribute (značajke), izvršiti podjelu na trening i testni skup podataka, pri čemu za testni skup treba uzeti 20% podataka.

"""

from sklearn.model_selection import train_test_split

data_train, data_test, new_train, new_test = train_test_split(data, new,test_size=0.20)

"""### Zadatak 3 - Klasični algoritam mašinskog učenja

U ovom zadatku, upoznat ćemo se sa primjenom Sklearn biblioteke u klasičnim algoritimma mašinskog učenja.
Konkretno, radit će se klasifikacija cvijeta iris na tri različite vrste (prikazane na slici 21), i to:
*   Setosa;
*   Versicolour;
*   Virginica. \\

Algoritam će prvo na osnovu postojećeg skupa podataka, koji sadrži značajke i labele, naučiti kako koja značajka
djeluje samu vrstu cvijeta, te će biti u stanju da za novi (neviđeni) podatak pretpostavi tačnu klasu kojoj cvijet
pripada.

####(a)  Sam skup podataka dolazi spreman uz Sklearn, te ga je potrebno učitati:
"""

from sklearn.datasets import load_iris

iris = load_iris()
X = iris.data
y = iris.target

feature_names = iris.feature_names
target_names = iris.target_names

print("Nazivi znacajki:", feature_names)
print("Nazivi labela:", target_names)
print("\nPrvih 5 redova X:\n", X[:5])

"""####(b)  Sljedeći korak jeste dijeljenje skupa podataka na dva dijela - trening i testni skup. 
Trening skup se koristi kako bi algoritam naučio uzorke ponašanja, dok testni skup predstavlja nove podatke, na osnovu kojih se vrši evaluacija algoritma (to jeste evaluacija naučenog). Dijeljenje skupa podataka se vrši na ranije opisani način:
"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 1)

print(X_train.shape)
print(X_test.shape)

print(y_train.shape)
print(y_test.shape)

"""####(c) Sada je vrijeme da se primijeni odgovarajući algoritam. U ovom primjeru, koristit ćemo k-NN (eng. *k-nearest neighbours*). 
Ovaj algoritam je izuzetno jednostavan, te klasifikaciju vrši na način da svaki podatak mapira kao
n-dimenzionalnu tačku. Klasa novog podatka se zatim određuje na osnovu k najbližih tačaka u tom prostoru.
Uzima se ona klasa koja se pojavljuje najčešće u *k* najbližih susjeda. Ovaj algoritam je već implementiran u
sklopu Sklearn, pa se može jednostavno pozvati:

"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn import metrics

classifier_knn = KNeighborsClassifier(n_neighbors = 3)

classifier_knn.fit(X_train, y_train)